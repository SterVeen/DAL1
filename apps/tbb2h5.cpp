/*-------------------------------------------------------------------------*
 | $Id:: templates.h 391 2007-06-13 09:25:11Z baehren                    $ |
 *-------------------------------------------------------------------------*
 ***************************************************************************
 *   Copyright (C) 2007 by Joseph Masters                                  *
 *   jmasters@science.uva.nl                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

/*!
  \file tbb2h5.cpp

  \ingroup DAL

  \brief Write TBB time-series data into an HDF5 file.

  \author Joseph Masters, Lars B&auml;hren

  <h3>Prerequisite</h3>

  - DAL::TBB -- High-level interface between TBB data and the DAL; provides the
  method which carry out the data handling.
  
  - select -- synchronous I/O multiplexing. 
  If timeout is a non-nil pointer, it specifies a maximum interval to wait
  for the selection to complete.  If timeout is a nil pointer, the select
  blocks indefinitely.  To effect a poll, the timeout argument should be
  non-nil, pointing to a zero-valued timeval structure.  Timeout is not
  changed by select(), and may be reused on subsequent calls, however it is
  good style to re-initialize it before each invocation of select().
  
  <h4>Usage</h4>

  \t tbb2h5 supports reading in the raw TBB time-series data from two different
  types of sources: in \e file-mode data are read in from a dump file, whereas in
  \e socket-mode input is accepted from a socket.

  <table border="0">
    <tr>
    <td class="indexkey">Command line</td>
    <td class="indexkey">Decription</td>
    </tr>
    <tr>
      <td>-H [--help]</td>
      <td>Show help messages</td>
    </tr>
    <tr>
      <td>-O [--outfile] arg</td>
      <td>Name of the output dataset</td>
    </tr>
    <tr>
      <td>-I [--infile] arg</td>
      <td>Name of the input file</td>
    </tr>
    <tr>
      <td>-M [--mode] arg</td>
      <td>Operation mode: file (0), socket (1)</td>
    </tr>
    <tr>
      <td>--ip arg</td>
      <td>IP address from which to accept the data</td>
    </tr>
    <tr>
      <td>-P [--port] arg</td>
      <td>Port number to accept data from</td>
    </tr>
    <tr>
      <td>-T [--timeout] arg</td>
      <td>Time-out before stop listening to the port. If the provided value
      is smaller but zero (which is the default) the connection to the port is
      kept open indefinitely.</td>
    </tr>
    <tr>
      <td>-A [--antpos] arg</td>
      <td>File containing the positions of the individual antennas</td>
    </tr>
    <tr>
      <td>-F [--fixTimes] arg</td>
      <td>Fix broken time stamps (generated by the RSPs and passed through by the TBBs).
      (0): do not change time stamps
      (1): change old style time stamps: substract 1 from the second-counter of the last 
      frame of a second and add 512 to the sample_nr of (true) odd-numbered second frames 
      in 200MHz mode
      (2): change new style time stamps: add 512 to the sample_nr of odd-numbered second 
      frames in 200MHz mode
      </td>
    </tr>
  </table>

  Even though \e mode serves as main switch for deciding whether \b tbb2h5
  attempts to read from a file or from a socket, the secondary parameters --
  \e infile for file mode, \e ip and \e port for socket mode -- can be used to 
  determine the basic behaviour.

  <ul>
    <li>Convert file with dump of raw TBB data to a HDF5 file:
    \verbatim
    tbb2h5 --infile <raw data> --outfile <HDF5 output>
    \endverbatim
    <li>Read data from socket to a HDF5 file:
    \verbatim
    tbb2h5 --ip <IP address> --port <port number> --outfile <HDF5 output>
    \endverbatim
    <li>Read antenna positions from a calibration file and write them to a
    previously created HDF5 file:
    \verbatim
    tbb2h5 --antpos <antenna positions> --outfile <HDF5 output>
    \endverbatim
  </ul>
*/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifndef TBB_H
#include "TBB.h"
#endif

#include <boost/program_options.hpp>
#include <boost/program_options/cmdline.hpp>
#include <boost/program_options/options_description.hpp>
#include <boost/program_options/detail/cmdline.hpp>
namespace bpo = boost::program_options;

using namespace DAL;

//_______________________________________________________________________________
// Print usage examples

void print_examples (std::ostream &os)
{
  os << "[tbb2h5] Usage examples." << std::endl;
  os << std::endl;
  os << "1) Convert file with dump of raw TBB data to a HDF5 file:" << std::endl;
  os << "  tbb2h5 --infile <raw data> --outfile <HDF5 output>" << std::endl;
  os << std::endl;
  os << "2) Read data from socket to a HDF5 file:" << std::endl;
  os << "  tbb2h5 --ip <IP address> --port <port number> --outfile <HDF5 output>" << std::endl;
  os << std::endl;
}

//_______________________________________________________________________________
// Program main function

int main(int argc, char *argv[])
{
  std::string infile;
  std::string outfile;
  std::string antpos;
  std::string ip;
  std::string port;
  int socketmode (0);
  int timeout (-1);

  int fixTransientTimes (0);
  bool file2hdf5 (false);
  bool positions2hdf5 (false);

  // -----------------------------------------------------------------
  // Processing of command line options

  bpo::options_description desc ("[tbb2h5] Available command line options");
  
  desc.add_options ()
    ("help,H", "Show help messages")
    ("outfile,O",bpo::value<std::string>(), "Name of the output dataset")
    ("infile,I", bpo::value<std::string>(), "Name of the input file")
    ("mode,M", bpo::value<int>(), "Operation mode: file (0), socket (1)")
    ("ip", bpo::value<std::string>(), "IP address from which to accept the data")
    ("port,P", bpo::value<std::string>(), "Port number to accept data from")
    ("timeout,T", bpo::value<int>(), "Time-out before stop listening to the port")
    ("fixTimes,F", bpo::value<int>(), "Fix broken time-stamps old style (1), new style (2), or not (0, default)")
    ("antpos,A", bpo::value<std::string>(), "File containing antenna positions")
    ;
  
  bpo::variables_map vm;
  bpo::store (bpo::parse_command_line(argc,argv,desc), vm);

  if (vm.count("help") || argc == 1) {
    std::cout << "\n" << desc << std::endl;
    return 0;
  }

  if (vm.count("infile")) {
    infile     = vm["infile"].as<std::string>();
    socketmode = 0;
  }

  if (vm.count("outfile")) {
    outfile = vm["outfile"].as<std::string>();
  }

  if (vm.count("antpos")) {
    outfile = vm["antpos"].as<std::string>();
  }

  if (vm.count("ip")) {
    ip = vm["ip"].as<std::string>();
    socketmode = 1;
  }

  if (vm.count("port")) {
    port = vm["port"].as<std::string>();
    socketmode = 1;
  }

  if (vm.count("mode")) {
    socketmode = vm["mode"].as<int>();
  }

  if (vm.count("timeout")) {
    timeout = vm["timeout"].as<int>();
  }

  if (vm.count("fixTimes")) {
    fixTransientTimes = vm["fixTimes"].as<int>();
  }

  // -----------------------------------------------------------------
  // Check the provided input
  
  if (fixTransientTimes>0) {
    cout << "Going to fix (probably) broken time-stamps." << endl;
    cout << "!!! Only tested for transient (=raw) data!!!" << endl;
  };

  switch (socketmode) {
  case 0:
    {
      if (vm.count("infile") || vm.count("outfile")) {
	file2hdf5 = true;
      } 
      else if (vm.count("antpos") || vm.count("outfile")) {
	positions2hdf5 = true;
      } else {
	std::cerr << "Incomplete list of parameters for file mode!" << std::endl;
	std::cerr << desc << std::endl;
	return DAL::FAIL;
      }
    }
    break;
  case 1:
    if (!vm.count("ip") || !vm.count("port")) {
      std::cerr << "Incomplete list of parameters for socket mode!" << std::endl;
      std::cerr << desc << std::endl;
      print_examples(std::cerr);
      return DAL::FAIL;
    }
    break;
  }

  // -----------------------------------------------------------------
  // Feedback on the settings
  
  std::cout << "[tbb2h5] Summary of parameters"  << std::endl;
  std::cout << "-- Socket mode = " << socketmode << std::endl;
  std::cout << "-- Output file = " << outfile    << std::endl;
  
  if (socketmode) {
    std::cout << "-- IP address  = " << ip      << std::endl;
    std::cout << "-- Port number = " << port    << std::endl;
    std::cout << "-- Timeout     = " << timeout << std::endl;
  } else {
    std::cout << "-- Input file  = " << infile  << std::endl;
  }
  
  // -----------------------------------------------------------------
  // Start processing of the input data
  
  TBB tbb = TBB( outfile );
  
  if ( socketmode )  // socket mode?
    {
      std::cout << "[tbb2h5] Opening connection to socket ..." << std::endl;
      tbb.connectsocket( ip.c_str(), port.c_str(), timeout );
    }
  else  // reading from a file
    {
      std::cout << "[tbb2h5] Opening input raw file ..." << std::endl;
      if ( !tbb.openRawFile( infile.c_str() ) )
        return DAL::FAIL;
    }
  
  int counter = 0;
  
  if (socketmode)  // reading from a socket
    {

      while ( true )
        {
          counter++;
	  
          if ( !tbb.readRawSocketBlockHeader() )
            break;
	  
	  if (fixTransientTimes==1) {
	    tbb.fixDate();
	  } else if (fixTransientTimes==2) {	 
	    tbb.fixDateNew();
	  };
 
          tbb.stationCheck();
	  
          // if this is the first sample for this station, set header attributes
          if ( tbb.first_sample )
            {
              tbb.makeOutputHeader();
              tbb.first_sample = false;
            }
	  
          if ( tbb.transientMode() )
            {
#ifdef DEBUGGING_MESSAGES
              cerr << "block " << counter << endl;
#endif
              if ( !tbb.processTransientSocketDataBlock() )
                break;
            }

        } // while (true)
      
    }
  else  // reading from a file
    {
      while ( !tbb.eof() )
        {
          counter++;

	  /* Read header block of raw file */
          tbb.readRawFileBlockHeader();

	  /* try to fix broken time-stamps if requested */
	  if (fixTransientTimes) {
	    tbb.fixDate();
	  };	 

	  /* Check station ID of the data */
          tbb.stationCheck();

          // if this is the first sample for this station set header attributes
          if ( tbb.first_sample )
            {
              tbb.makeOutputHeader();
              tbb.first_sample = false;
            }

#ifdef DEBUGGING_MESSAGES
          cerr << "block " << counter << endl;
#endif

          if ( tbb.transientMode() )
            {
              tbb.processTransientFileDataBlock();
            }
          else  // spectral mode
            {
              tbb.processSpectralFileDataBlock();
            }

          // cleanup open groups, etc.
          tbb.cleanup();

        } // !eof

    } // socket or file

  cout << "No of processed blocks " << counter << endl;
  cout << "SUCCESS" << endl;
  return 0;
} // main
